{"ast":null,"code":"/*!\n * express-session\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\nvar Buffer = require('safe-buffer').Buffer;\nvar cookie = require('cookie');\nvar crypto = require('crypto');\nvar debug = require('debug')('express-session');\nvar deprecate = require('depd')('express-session');\nvar onHeaders = require('on-headers');\nvar parseUrl = require('parseurl');\nvar signature = require('cookie-signature');\nvar uid = require('uid-safe').sync;\nvar Cookie = require('./session/cookie');\nvar MemoryStore = require('./session/memory');\nvar Session = require('./session/session');\nvar Store = require('./session/store');\n\n// environment\n\nvar env = process.env.NODE_ENV;\n\n/**\n * Expose the middleware.\n */\n\nexports = module.exports = session;\n\n/**\n * Expose constructors.\n */\n\nexports.Store = Store;\nexports.Cookie = Cookie;\nexports.Session = Session;\nexports.MemoryStore = MemoryStore;\n\n/**\n * Warning message for `MemoryStore` usage in production.\n * @private\n */\n\nvar warning = 'Warning: connect.session() MemoryStore is not\\n' + 'designed for a production environment, as it will leak\\n' + 'memory, and will not scale past a single process.';\n\n/**\n * Node.js 0.8+ async implementation.\n * @private\n */\n\n/* istanbul ignore next */\nvar defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {\n  process.nextTick(fn.bind.apply(fn, arguments));\n};\n\n/**\n * Setup session store with the given `options`.\n *\n * @param {Object} [options]\n * @param {Object} [options.cookie] Options for cookie\n * @param {Function} [options.genid]\n * @param {String} [options.name=connect.sid] Session ID cookie name\n * @param {Boolean} [options.proxy]\n * @param {Boolean} [options.resave] Resave unmodified sessions back to the store\n * @param {Boolean} [options.rolling] Enable/disable rolling session expiration\n * @param {Boolean} [options.saveUninitialized] Save uninitialized sessions to the store\n * @param {String|Array} [options.secret] Secret for signing session ID\n * @param {Object} [options.store=MemoryStore] Session store\n * @param {String} [options.unset]\n * @return {Function} middleware\n * @public\n */\n\nfunction session(options) {\n  var opts = options || {};\n\n  // get the cookie options\n  var cookieOptions = opts.cookie || {};\n\n  // get the session id generate function\n  var generateId = opts.genid || generateSessionId;\n\n  // get the session cookie name\n  var name = opts.name || opts.key || 'connect.sid';\n\n  // get the session store\n  var store = opts.store || new MemoryStore();\n\n  // get the trust proxy setting\n  var trustProxy = opts.proxy;\n\n  // get the resave session option\n  var resaveSession = opts.resave;\n\n  // get the rolling session option\n  var rollingSessions = Boolean(opts.rolling);\n\n  // get the save uninitialized session option\n  var saveUninitializedSession = opts.saveUninitialized;\n\n  // get the cookie signing secret\n  var secret = opts.secret;\n  if (typeof generateId !== 'function') {\n    throw new TypeError('genid option must be a function');\n  }\n  if (resaveSession === undefined) {\n    deprecate('undefined resave option; provide resave option');\n    resaveSession = true;\n  }\n  if (saveUninitializedSession === undefined) {\n    deprecate('undefined saveUninitialized option; provide saveUninitialized option');\n    saveUninitializedSession = true;\n  }\n  if (opts.unset && opts.unset !== 'destroy' && opts.unset !== 'keep') {\n    throw new TypeError('unset option must be \"destroy\" or \"keep\"');\n  }\n\n  // TODO: switch to \"destroy\" on next major\n  var unsetDestroy = opts.unset === 'destroy';\n  if (Array.isArray(secret) && secret.length === 0) {\n    throw new TypeError('secret option array must contain one or more strings');\n  }\n  if (secret && !Array.isArray(secret)) {\n    secret = [secret];\n  }\n  if (!secret) {\n    deprecate('req.secret; provide secret option');\n  }\n\n  // notify user that this store is not\n  // meant for a production environment\n  /* istanbul ignore next: not tested */\n  if (env === 'production' && store instanceof MemoryStore) {\n    console.warn(warning);\n  }\n\n  // generates the new session\n  store.generate = function (req) {\n    req.sessionID = generateId(req);\n    req.session = new Session(req);\n    req.session.cookie = new Cookie(cookieOptions);\n    if (cookieOptions.secure === 'auto') {\n      req.session.cookie.secure = issecure(req, trustProxy);\n    }\n  };\n  var storeImplementsTouch = typeof store.touch === 'function';\n\n  // register event listeners for the store to track readiness\n  var storeReady = true;\n  store.on('disconnect', function ondisconnect() {\n    storeReady = false;\n  });\n  store.on('connect', function onconnect() {\n    storeReady = true;\n  });\n  return function session(req, res, next) {\n    // self-awareness\n    if (req.session) {\n      next();\n      return;\n    }\n\n    // Handle connection as if there is no session if\n    // the store has temporarily disconnected etc\n    if (!storeReady) {\n      debug('store is disconnected');\n      next();\n      return;\n    }\n\n    // pathname mismatch\n    var originalPath = parseUrl.original(req).pathname || '/';\n    if (originalPath.indexOf(cookieOptions.path || '/') !== 0) return next();\n\n    // ensure a secret is available or bail\n    if (!secret && !req.secret) {\n      next(new Error('secret option required for sessions'));\n      return;\n    }\n\n    // backwards compatibility for signed cookies\n    // req.secret is passed from the cookie parser middleware\n    var secrets = secret || [req.secret];\n    var originalHash;\n    var originalId;\n    var savedHash;\n    var touched = false;\n\n    // expose store\n    req.sessionStore = store;\n\n    // get the session ID from the cookie\n    var cookieId = req.sessionID = getcookie(req, name, secrets);\n\n    // set-cookie\n    onHeaders(res, function () {\n      if (!req.session) {\n        debug('no session');\n        return;\n      }\n      if (!shouldSetCookie(req)) {\n        return;\n      }\n\n      // only send secure cookies via https\n      if (req.session.cookie.secure && !issecure(req, trustProxy)) {\n        debug('not secured');\n        return;\n      }\n      if (!touched) {\n        // touch session\n        req.session.touch();\n        touched = true;\n      }\n\n      // set cookie\n      setcookie(res, name, req.sessionID, secrets[0], req.session.cookie.data);\n    });\n\n    // proxy end() to commit the session\n    var _end = res.end;\n    var _write = res.write;\n    var ended = false;\n    res.end = function end(chunk, encoding) {\n      if (ended) {\n        return false;\n      }\n      ended = true;\n      var ret;\n      var sync = true;\n      function writeend() {\n        if (sync) {\n          ret = _end.call(res, chunk, encoding);\n          sync = false;\n          return;\n        }\n        _end.call(res);\n      }\n      function writetop() {\n        if (!sync) {\n          return ret;\n        }\n        if (!res._header) {\n          res._implicitHeader();\n        }\n        if (chunk == null) {\n          ret = true;\n          return ret;\n        }\n        var contentLength = Number(res.getHeader('Content-Length'));\n        if (!isNaN(contentLength) && contentLength > 0) {\n          // measure chunk\n          chunk = !Buffer.isBuffer(chunk) ? Buffer.from(chunk, encoding) : chunk;\n          encoding = undefined;\n          if (chunk.length !== 0) {\n            debug('split response');\n            ret = _write.call(res, chunk.slice(0, chunk.length - 1));\n            chunk = chunk.slice(chunk.length - 1, chunk.length);\n            return ret;\n          }\n        }\n        ret = _write.call(res, chunk, encoding);\n        sync = false;\n        return ret;\n      }\n      if (shouldDestroy(req)) {\n        // destroy session\n        debug('destroying');\n        store.destroy(req.sessionID, function ondestroy(err) {\n          if (err) {\n            defer(next, err);\n          }\n          debug('destroyed');\n          writeend();\n        });\n        return writetop();\n      }\n\n      // no session to save\n      if (!req.session) {\n        debug('no session');\n        return _end.call(res, chunk, encoding);\n      }\n      if (!touched) {\n        // touch session\n        req.session.touch();\n        touched = true;\n      }\n      if (shouldSave(req)) {\n        req.session.save(function onsave(err) {\n          if (err) {\n            defer(next, err);\n          }\n          writeend();\n        });\n        return writetop();\n      } else if (storeImplementsTouch && shouldTouch(req)) {\n        // store implements touch method\n        debug('touching');\n        store.touch(req.sessionID, req.session, function ontouch(err) {\n          if (err) {\n            defer(next, err);\n          }\n          debug('touched');\n          writeend();\n        });\n        return writetop();\n      }\n      return _end.call(res, chunk, encoding);\n    };\n\n    // generate the session\n    function generate() {\n      store.generate(req);\n      originalId = req.sessionID;\n      originalHash = hash(req.session);\n      wrapmethods(req.session);\n    }\n\n    // inflate the session\n    function inflate(req, sess) {\n      store.createSession(req, sess);\n      originalId = req.sessionID;\n      originalHash = hash(sess);\n      if (!resaveSession) {\n        savedHash = originalHash;\n      }\n      wrapmethods(req.session);\n    }\n    function rewrapmethods(sess, callback) {\n      return function () {\n        if (req.session !== sess) {\n          wrapmethods(req.session);\n        }\n        callback.apply(this, arguments);\n      };\n    }\n\n    // wrap session methods\n    function wrapmethods(sess) {\n      var _reload = sess.reload;\n      var _save = sess.save;\n      function reload(callback) {\n        debug('reloading %s', this.id);\n        _reload.call(this, rewrapmethods(this, callback));\n      }\n      function save() {\n        debug('saving %s', this.id);\n        savedHash = hash(this);\n        _save.apply(this, arguments);\n      }\n      Object.defineProperty(sess, 'reload', {\n        configurable: true,\n        enumerable: false,\n        value: reload,\n        writable: true\n      });\n      Object.defineProperty(sess, 'save', {\n        configurable: true,\n        enumerable: false,\n        value: save,\n        writable: true\n      });\n    }\n\n    // check if session has been modified\n    function isModified(sess) {\n      return originalId !== sess.id || originalHash !== hash(sess);\n    }\n\n    // check if session has been saved\n    function isSaved(sess) {\n      return originalId === sess.id && savedHash === hash(sess);\n    }\n\n    // determine if session should be destroyed\n    function shouldDestroy(req) {\n      return req.sessionID && unsetDestroy && req.session == null;\n    }\n\n    // determine if session should be saved to store\n    function shouldSave(req) {\n      // cannot set cookie without a session ID\n      if (typeof req.sessionID !== 'string') {\n        debug('session ignored because of bogus req.sessionID %o', req.sessionID);\n        return false;\n      }\n      return !saveUninitializedSession && !savedHash && cookieId !== req.sessionID ? isModified(req.session) : !isSaved(req.session);\n    }\n\n    // determine if session should be touched\n    function shouldTouch(req) {\n      // cannot set cookie without a session ID\n      if (typeof req.sessionID !== 'string') {\n        debug('session ignored because of bogus req.sessionID %o', req.sessionID);\n        return false;\n      }\n      return cookieId === req.sessionID && !shouldSave(req);\n    }\n\n    // determine if cookie should be set on response\n    function shouldSetCookie(req) {\n      // cannot set cookie without a session ID\n      if (typeof req.sessionID !== 'string') {\n        return false;\n      }\n      return cookieId !== req.sessionID ? saveUninitializedSession || isModified(req.session) : rollingSessions || req.session.cookie.expires != null && isModified(req.session);\n    }\n\n    // generate a session if the browser doesn't send a sessionID\n    if (!req.sessionID) {\n      debug('no SID sent, generating session');\n      generate();\n      next();\n      return;\n    }\n\n    // generate the session object\n    debug('fetching %s', req.sessionID);\n    store.get(req.sessionID, function (err, sess) {\n      // error handling\n      if (err && err.code !== 'ENOENT') {\n        debug('error %j', err);\n        next(err);\n        return;\n      }\n      try {\n        if (err || !sess) {\n          debug('no session found');\n          generate();\n        } else {\n          debug('session found');\n          inflate(req, sess);\n        }\n      } catch (e) {\n        next(e);\n        return;\n      }\n      next();\n    });\n  };\n}\n;\n\n/**\n * Generate a session ID for a new session.\n *\n * @return {String}\n * @private\n */\n\nfunction generateSessionId(sess) {\n  return uid(24);\n}\n\n/**\n * Get the session ID cookie from request.\n *\n * @return {string}\n * @private\n */\n\nfunction getcookie(req, name, secrets) {\n  var header = req.headers.cookie;\n  var raw;\n  var val;\n\n  // read from cookie header\n  if (header) {\n    var cookies = cookie.parse(header);\n    raw = cookies[name];\n    if (raw) {\n      if (raw.substr(0, 2) === 's:') {\n        val = unsigncookie(raw.slice(2), secrets);\n        if (val === false) {\n          debug('cookie signature invalid');\n          val = undefined;\n        }\n      } else {\n        debug('cookie unsigned');\n      }\n    }\n  }\n\n  // back-compat read from cookieParser() signedCookies data\n  if (!val && req.signedCookies) {\n    val = req.signedCookies[name];\n    if (val) {\n      deprecate('cookie should be available in req.headers.cookie');\n    }\n  }\n\n  // back-compat read from cookieParser() cookies data\n  if (!val && req.cookies) {\n    raw = req.cookies[name];\n    if (raw) {\n      if (raw.substr(0, 2) === 's:') {\n        val = unsigncookie(raw.slice(2), secrets);\n        if (val) {\n          deprecate('cookie should be available in req.headers.cookie');\n        }\n        if (val === false) {\n          debug('cookie signature invalid');\n          val = undefined;\n        }\n      } else {\n        debug('cookie unsigned');\n      }\n    }\n  }\n  return val;\n}\n\n/**\n * Hash the given `sess` object omitting changes to `.cookie`.\n *\n * @param {Object} sess\n * @return {String}\n * @private\n */\n\nfunction hash(sess) {\n  // serialize\n  var str = JSON.stringify(sess, function (key, val) {\n    // ignore sess.cookie property\n    if (this === sess && key === 'cookie') {\n      return;\n    }\n    return val;\n  });\n\n  // hash\n  return crypto.createHash('sha1').update(str, 'utf8').digest('hex');\n}\n\n/**\n * Determine if request is secure.\n *\n * @param {Object} req\n * @param {Boolean} [trustProxy]\n * @return {Boolean}\n * @private\n */\n\nfunction issecure(req, trustProxy) {\n  // socket is https server\n  if (req.connection && req.connection.encrypted) {\n    return true;\n  }\n\n  // do not trust proxy\n  if (trustProxy === false) {\n    return false;\n  }\n\n  // no explicit trust; try req.secure from express\n  if (trustProxy !== true) {\n    return req.secure === true;\n  }\n\n  // read the proto from x-forwarded-proto header\n  var header = req.headers['x-forwarded-proto'] || '';\n  var index = header.indexOf(',');\n  var proto = index !== -1 ? header.substr(0, index).toLowerCase().trim() : header.toLowerCase().trim();\n  return proto === 'https';\n}\n\n/**\n * Set cookie on response.\n *\n * @private\n */\n\nfunction setcookie(res, name, val, secret, options) {\n  var signed = 's:' + signature.sign(val, secret);\n  var data = cookie.serialize(name, signed, options);\n  debug('set-cookie %s', data);\n  var prev = res.getHeader('Set-Cookie') || [];\n  var header = Array.isArray(prev) ? prev.concat(data) : [prev, data];\n  res.setHeader('Set-Cookie', header);\n}\n\n/**\n * Verify and decode the given `val` with `secrets`.\n *\n * @param {String} val\n * @param {Array} secrets\n * @returns {String|Boolean}\n * @private\n */\nfunction unsigncookie(val, secrets) {\n  for (var i = 0; i < secrets.length; i++) {\n    var result = signature.unsign(val, secrets[i]);\n    if (result !== false) {\n      return result;\n    }\n  }\n  return false;\n}","map":{"version":3,"names":["Buffer","require","cookie","crypto","debug","deprecate","onHeaders","parseUrl","signature","uid","sync","Cookie","MemoryStore","Session","Store","env","process","NODE_ENV","exports","module","session","warning","defer","setImmediate","fn","nextTick","bind","apply","arguments","options","opts","cookieOptions","generateId","genid","generateSessionId","name","key","store","trustProxy","proxy","resaveSession","resave","rollingSessions","Boolean","rolling","saveUninitializedSession","saveUninitialized","secret","TypeError","undefined","unset","unsetDestroy","Array","isArray","length","console","warn","generate","req","sessionID","secure","issecure","storeImplementsTouch","touch","storeReady","on","ondisconnect","onconnect","res","next","originalPath","original","pathname","indexOf","path","Error","secrets","originalHash","originalId","savedHash","touched","sessionStore","cookieId","getcookie","shouldSetCookie","setcookie","data","_end","end","_write","write","ended","chunk","encoding","ret","writeend","call","writetop","_header","_implicitHeader","contentLength","Number","getHeader","isNaN","isBuffer","from","slice","shouldDestroy","destroy","ondestroy","err","shouldSave","save","onsave","shouldTouch","ontouch","hash","wrapmethods","inflate","sess","createSession","rewrapmethods","callback","_reload","reload","_save","id","Object","defineProperty","configurable","enumerable","value","writable","isModified","isSaved","expires","get","code","e","header","headers","raw","val","cookies","parse","substr","unsigncookie","signedCookies","str","JSON","stringify","createHash","update","digest","connection","encrypted","index","proto","toLowerCase","trim","signed","sign","serialize","prev","concat","setHeader","i","result","unsign"],"sources":["K:/machine/rest_api/sync/html/client/client/node_modules/express-session/index.js"],"sourcesContent":["/*!\n * express-session\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar Buffer = require('safe-buffer').Buffer\nvar cookie = require('cookie');\nvar crypto = require('crypto')\nvar debug = require('debug')('express-session');\nvar deprecate = require('depd')('express-session');\nvar onHeaders = require('on-headers')\nvar parseUrl = require('parseurl');\nvar signature = require('cookie-signature')\nvar uid = require('uid-safe').sync\n\nvar Cookie = require('./session/cookie')\nvar MemoryStore = require('./session/memory')\nvar Session = require('./session/session')\nvar Store = require('./session/store')\n\n// environment\n\nvar env = process.env.NODE_ENV;\n\n/**\n * Expose the middleware.\n */\n\nexports = module.exports = session;\n\n/**\n * Expose constructors.\n */\n\nexports.Store = Store;\nexports.Cookie = Cookie;\nexports.Session = Session;\nexports.MemoryStore = MemoryStore;\n\n/**\n * Warning message for `MemoryStore` usage in production.\n * @private\n */\n\nvar warning = 'Warning: connect.session() MemoryStore is not\\n'\n  + 'designed for a production environment, as it will leak\\n'\n  + 'memory, and will not scale past a single process.';\n\n/**\n * Node.js 0.8+ async implementation.\n * @private\n */\n\n/* istanbul ignore next */\nvar defer = typeof setImmediate === 'function'\n  ? setImmediate\n  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }\n\n/**\n * Setup session store with the given `options`.\n *\n * @param {Object} [options]\n * @param {Object} [options.cookie] Options for cookie\n * @param {Function} [options.genid]\n * @param {String} [options.name=connect.sid] Session ID cookie name\n * @param {Boolean} [options.proxy]\n * @param {Boolean} [options.resave] Resave unmodified sessions back to the store\n * @param {Boolean} [options.rolling] Enable/disable rolling session expiration\n * @param {Boolean} [options.saveUninitialized] Save uninitialized sessions to the store\n * @param {String|Array} [options.secret] Secret for signing session ID\n * @param {Object} [options.store=MemoryStore] Session store\n * @param {String} [options.unset]\n * @return {Function} middleware\n * @public\n */\n\nfunction session(options) {\n  var opts = options || {}\n\n  // get the cookie options\n  var cookieOptions = opts.cookie || {}\n\n  // get the session id generate function\n  var generateId = opts.genid || generateSessionId\n\n  // get the session cookie name\n  var name = opts.name || opts.key || 'connect.sid'\n\n  // get the session store\n  var store = opts.store || new MemoryStore()\n\n  // get the trust proxy setting\n  var trustProxy = opts.proxy\n\n  // get the resave session option\n  var resaveSession = opts.resave;\n\n  // get the rolling session option\n  var rollingSessions = Boolean(opts.rolling)\n\n  // get the save uninitialized session option\n  var saveUninitializedSession = opts.saveUninitialized\n\n  // get the cookie signing secret\n  var secret = opts.secret\n\n  if (typeof generateId !== 'function') {\n    throw new TypeError('genid option must be a function');\n  }\n\n  if (resaveSession === undefined) {\n    deprecate('undefined resave option; provide resave option');\n    resaveSession = true;\n  }\n\n  if (saveUninitializedSession === undefined) {\n    deprecate('undefined saveUninitialized option; provide saveUninitialized option');\n    saveUninitializedSession = true;\n  }\n\n  if (opts.unset && opts.unset !== 'destroy' && opts.unset !== 'keep') {\n    throw new TypeError('unset option must be \"destroy\" or \"keep\"');\n  }\n\n  // TODO: switch to \"destroy\" on next major\n  var unsetDestroy = opts.unset === 'destroy'\n\n  if (Array.isArray(secret) && secret.length === 0) {\n    throw new TypeError('secret option array must contain one or more strings');\n  }\n\n  if (secret && !Array.isArray(secret)) {\n    secret = [secret];\n  }\n\n  if (!secret) {\n    deprecate('req.secret; provide secret option');\n  }\n\n  // notify user that this store is not\n  // meant for a production environment\n  /* istanbul ignore next: not tested */\n  if (env === 'production' && store instanceof MemoryStore) {\n    console.warn(warning);\n  }\n\n  // generates the new session\n  store.generate = function(req){\n    req.sessionID = generateId(req);\n    req.session = new Session(req);\n    req.session.cookie = new Cookie(cookieOptions);\n\n    if (cookieOptions.secure === 'auto') {\n      req.session.cookie.secure = issecure(req, trustProxy);\n    }\n  };\n\n  var storeImplementsTouch = typeof store.touch === 'function';\n\n  // register event listeners for the store to track readiness\n  var storeReady = true\n  store.on('disconnect', function ondisconnect() {\n    storeReady = false\n  })\n  store.on('connect', function onconnect() {\n    storeReady = true\n  })\n\n  return function session(req, res, next) {\n    // self-awareness\n    if (req.session) {\n      next()\n      return\n    }\n\n    // Handle connection as if there is no session if\n    // the store has temporarily disconnected etc\n    if (!storeReady) {\n      debug('store is disconnected')\n      next()\n      return\n    }\n\n    // pathname mismatch\n    var originalPath = parseUrl.original(req).pathname || '/'\n    if (originalPath.indexOf(cookieOptions.path || '/') !== 0) return next();\n\n    // ensure a secret is available or bail\n    if (!secret && !req.secret) {\n      next(new Error('secret option required for sessions'));\n      return;\n    }\n\n    // backwards compatibility for signed cookies\n    // req.secret is passed from the cookie parser middleware\n    var secrets = secret || [req.secret];\n\n    var originalHash;\n    var originalId;\n    var savedHash;\n    var touched = false\n\n    // expose store\n    req.sessionStore = store;\n\n    // get the session ID from the cookie\n    var cookieId = req.sessionID = getcookie(req, name, secrets);\n\n    // set-cookie\n    onHeaders(res, function(){\n      if (!req.session) {\n        debug('no session');\n        return;\n      }\n\n      if (!shouldSetCookie(req)) {\n        return;\n      }\n\n      // only send secure cookies via https\n      if (req.session.cookie.secure && !issecure(req, trustProxy)) {\n        debug('not secured');\n        return;\n      }\n\n      if (!touched) {\n        // touch session\n        req.session.touch()\n        touched = true\n      }\n\n      // set cookie\n      setcookie(res, name, req.sessionID, secrets[0], req.session.cookie.data);\n    });\n\n    // proxy end() to commit the session\n    var _end = res.end;\n    var _write = res.write;\n    var ended = false;\n    res.end = function end(chunk, encoding) {\n      if (ended) {\n        return false;\n      }\n\n      ended = true;\n\n      var ret;\n      var sync = true;\n\n      function writeend() {\n        if (sync) {\n          ret = _end.call(res, chunk, encoding);\n          sync = false;\n          return;\n        }\n\n        _end.call(res);\n      }\n\n      function writetop() {\n        if (!sync) {\n          return ret;\n        }\n\n        if (!res._header) {\n          res._implicitHeader()\n        }\n\n        if (chunk == null) {\n          ret = true;\n          return ret;\n        }\n\n        var contentLength = Number(res.getHeader('Content-Length'));\n\n        if (!isNaN(contentLength) && contentLength > 0) {\n          // measure chunk\n          chunk = !Buffer.isBuffer(chunk)\n            ? Buffer.from(chunk, encoding)\n            : chunk;\n          encoding = undefined;\n\n          if (chunk.length !== 0) {\n            debug('split response');\n            ret = _write.call(res, chunk.slice(0, chunk.length - 1));\n            chunk = chunk.slice(chunk.length - 1, chunk.length);\n            return ret;\n          }\n        }\n\n        ret = _write.call(res, chunk, encoding);\n        sync = false;\n\n        return ret;\n      }\n\n      if (shouldDestroy(req)) {\n        // destroy session\n        debug('destroying');\n        store.destroy(req.sessionID, function ondestroy(err) {\n          if (err) {\n            defer(next, err);\n          }\n\n          debug('destroyed');\n          writeend();\n        });\n\n        return writetop();\n      }\n\n      // no session to save\n      if (!req.session) {\n        debug('no session');\n        return _end.call(res, chunk, encoding);\n      }\n\n      if (!touched) {\n        // touch session\n        req.session.touch()\n        touched = true\n      }\n\n      if (shouldSave(req)) {\n        req.session.save(function onsave(err) {\n          if (err) {\n            defer(next, err);\n          }\n\n          writeend();\n        });\n\n        return writetop();\n      } else if (storeImplementsTouch && shouldTouch(req)) {\n        // store implements touch method\n        debug('touching');\n        store.touch(req.sessionID, req.session, function ontouch(err) {\n          if (err) {\n            defer(next, err);\n          }\n\n          debug('touched');\n          writeend();\n        });\n\n        return writetop();\n      }\n\n      return _end.call(res, chunk, encoding);\n    };\n\n    // generate the session\n    function generate() {\n      store.generate(req);\n      originalId = req.sessionID;\n      originalHash = hash(req.session);\n      wrapmethods(req.session);\n    }\n\n    // inflate the session\n    function inflate (req, sess) {\n      store.createSession(req, sess)\n      originalId = req.sessionID\n      originalHash = hash(sess)\n\n      if (!resaveSession) {\n        savedHash = originalHash\n      }\n\n      wrapmethods(req.session)\n    }\n\n    function rewrapmethods (sess, callback) {\n      return function () {\n        if (req.session !== sess) {\n          wrapmethods(req.session)\n        }\n\n        callback.apply(this, arguments)\n      }\n    }\n\n    // wrap session methods\n    function wrapmethods(sess) {\n      var _reload = sess.reload\n      var _save = sess.save;\n\n      function reload(callback) {\n        debug('reloading %s', this.id)\n        _reload.call(this, rewrapmethods(this, callback))\n      }\n\n      function save() {\n        debug('saving %s', this.id);\n        savedHash = hash(this);\n        _save.apply(this, arguments);\n      }\n\n      Object.defineProperty(sess, 'reload', {\n        configurable: true,\n        enumerable: false,\n        value: reload,\n        writable: true\n      })\n\n      Object.defineProperty(sess, 'save', {\n        configurable: true,\n        enumerable: false,\n        value: save,\n        writable: true\n      });\n    }\n\n    // check if session has been modified\n    function isModified(sess) {\n      return originalId !== sess.id || originalHash !== hash(sess);\n    }\n\n    // check if session has been saved\n    function isSaved(sess) {\n      return originalId === sess.id && savedHash === hash(sess);\n    }\n\n    // determine if session should be destroyed\n    function shouldDestroy(req) {\n      return req.sessionID && unsetDestroy && req.session == null;\n    }\n\n    // determine if session should be saved to store\n    function shouldSave(req) {\n      // cannot set cookie without a session ID\n      if (typeof req.sessionID !== 'string') {\n        debug('session ignored because of bogus req.sessionID %o', req.sessionID);\n        return false;\n      }\n\n      return !saveUninitializedSession && !savedHash && cookieId !== req.sessionID\n        ? isModified(req.session)\n        : !isSaved(req.session)\n    }\n\n    // determine if session should be touched\n    function shouldTouch(req) {\n      // cannot set cookie without a session ID\n      if (typeof req.sessionID !== 'string') {\n        debug('session ignored because of bogus req.sessionID %o', req.sessionID);\n        return false;\n      }\n\n      return cookieId === req.sessionID && !shouldSave(req);\n    }\n\n    // determine if cookie should be set on response\n    function shouldSetCookie(req) {\n      // cannot set cookie without a session ID\n      if (typeof req.sessionID !== 'string') {\n        return false;\n      }\n\n      return cookieId !== req.sessionID\n        ? saveUninitializedSession || isModified(req.session)\n        : rollingSessions || req.session.cookie.expires != null && isModified(req.session);\n    }\n\n    // generate a session if the browser doesn't send a sessionID\n    if (!req.sessionID) {\n      debug('no SID sent, generating session');\n      generate();\n      next();\n      return;\n    }\n\n    // generate the session object\n    debug('fetching %s', req.sessionID);\n    store.get(req.sessionID, function(err, sess){\n      // error handling\n      if (err && err.code !== 'ENOENT') {\n        debug('error %j', err);\n        next(err)\n        return\n      }\n\n      try {\n        if (err || !sess) {\n          debug('no session found')\n          generate()\n        } else {\n          debug('session found')\n          inflate(req, sess)\n        }\n      } catch (e) {\n        next(e)\n        return\n      }\n\n      next()\n    });\n  };\n};\n\n/**\n * Generate a session ID for a new session.\n *\n * @return {String}\n * @private\n */\n\nfunction generateSessionId(sess) {\n  return uid(24);\n}\n\n/**\n * Get the session ID cookie from request.\n *\n * @return {string}\n * @private\n */\n\nfunction getcookie(req, name, secrets) {\n  var header = req.headers.cookie;\n  var raw;\n  var val;\n\n  // read from cookie header\n  if (header) {\n    var cookies = cookie.parse(header);\n\n    raw = cookies[name];\n\n    if (raw) {\n      if (raw.substr(0, 2) === 's:') {\n        val = unsigncookie(raw.slice(2), secrets);\n\n        if (val === false) {\n          debug('cookie signature invalid');\n          val = undefined;\n        }\n      } else {\n        debug('cookie unsigned')\n      }\n    }\n  }\n\n  // back-compat read from cookieParser() signedCookies data\n  if (!val && req.signedCookies) {\n    val = req.signedCookies[name];\n\n    if (val) {\n      deprecate('cookie should be available in req.headers.cookie');\n    }\n  }\n\n  // back-compat read from cookieParser() cookies data\n  if (!val && req.cookies) {\n    raw = req.cookies[name];\n\n    if (raw) {\n      if (raw.substr(0, 2) === 's:') {\n        val = unsigncookie(raw.slice(2), secrets);\n\n        if (val) {\n          deprecate('cookie should be available in req.headers.cookie');\n        }\n\n        if (val === false) {\n          debug('cookie signature invalid');\n          val = undefined;\n        }\n      } else {\n        debug('cookie unsigned')\n      }\n    }\n  }\n\n  return val;\n}\n\n/**\n * Hash the given `sess` object omitting changes to `.cookie`.\n *\n * @param {Object} sess\n * @return {String}\n * @private\n */\n\nfunction hash(sess) {\n  // serialize\n  var str = JSON.stringify(sess, function (key, val) {\n    // ignore sess.cookie property\n    if (this === sess && key === 'cookie') {\n      return\n    }\n\n    return val\n  })\n\n  // hash\n  return crypto\n    .createHash('sha1')\n    .update(str, 'utf8')\n    .digest('hex')\n}\n\n/**\n * Determine if request is secure.\n *\n * @param {Object} req\n * @param {Boolean} [trustProxy]\n * @return {Boolean}\n * @private\n */\n\nfunction issecure(req, trustProxy) {\n  // socket is https server\n  if (req.connection && req.connection.encrypted) {\n    return true;\n  }\n\n  // do not trust proxy\n  if (trustProxy === false) {\n    return false;\n  }\n\n  // no explicit trust; try req.secure from express\n  if (trustProxy !== true) {\n    return req.secure === true\n  }\n\n  // read the proto from x-forwarded-proto header\n  var header = req.headers['x-forwarded-proto'] || '';\n  var index = header.indexOf(',');\n  var proto = index !== -1\n    ? header.substr(0, index).toLowerCase().trim()\n    : header.toLowerCase().trim()\n\n  return proto === 'https';\n}\n\n/**\n * Set cookie on response.\n *\n * @private\n */\n\nfunction setcookie(res, name, val, secret, options) {\n  var signed = 's:' + signature.sign(val, secret);\n  var data = cookie.serialize(name, signed, options);\n\n  debug('set-cookie %s', data);\n\n  var prev = res.getHeader('Set-Cookie') || []\n  var header = Array.isArray(prev) ? prev.concat(data) : [prev, data];\n\n  res.setHeader('Set-Cookie', header)\n}\n\n/**\n * Verify and decode the given `val` with `secrets`.\n *\n * @param {String} val\n * @param {Array} secrets\n * @returns {String|Boolean}\n * @private\n */\nfunction unsigncookie(val, secrets) {\n  for (var i = 0; i < secrets.length; i++) {\n    var result = signature.unsign(val, secrets[i]);\n\n    if (result !== false) {\n      return result;\n    }\n  }\n\n  return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}